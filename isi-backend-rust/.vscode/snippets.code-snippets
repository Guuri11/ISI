{
    /**
    * Business Logic Snippets
    */
    "Business Lib Domain Entity": {
        "prefix": "lib-domain-entity",
        "body": [
            "pub mod ${1:module_name} {",
            "\tpub mod errors;",
            "\tpub mod model;",
            "\tpub mod repository;",
            "\tpub mod use_cases {",
            "\t\tpub mod ${2:use_case};",
            "\t}",
            "${3:// pub mod value_objets; // incluir si aplica}",
            "}"
        ],
        "scope": "rust",
        "description": "Crea un bloque pub mod para un nuevo módulo de dominio, (business/lib.rs -> mod domain)"
    },
    "Business Lib Application Entity": {
        "prefix": "lib-application-entity",
        "body": [
            "pub mod ${1:module_name} {",
            "\tpub mod use_cases {",
            "\t\tpub mod ${2:use_case};",
            "\t}",
            "}"
        ],
        "scope": "rust",
        "description": "Crea un bloque pub mod para un nuevo módulo de aplicación (business/lib.rs -> mod application)"
    },
    "Business Domain Model": {
        "prefix": "business-domain-model",
        "body": [
            "// === Bloque de derive (elige según tu caso) ===",
            "// #[derive(Debug)]                       // Para imprimir en consola (útil en desarrollo)",
            "// #[derive(Clone)]                      // Para clonar structs fácilmente",
            "// #[derive(Serialize, Deserialize)]     // Para convertir desde/hacia JSON u otros formatos",
            "// #[derive(PartialEq, Eq, Hash)]        // Para comparar, o usar en HashMaps o HashSets",
            "// #[derive(Default)]                    // Para construir una instancia vacía si aplica",
            "",
            "use chrono::NaiveDateTime;",
            "use serde::{Deserialize, Serialize};",
            "use uuid::Uuid;",
            "",
            "#[derive(Debug, Clone, Deserialize, Serialize)]",
            "pub struct ${1:EntityName} {",
            "    id: Uuid,",
            "    created_at: NaiveDateTime,",
            "    updated_at: NaiveDateTime,",
            "    deleted: bool,",
            "    deleted_at: Option<NaiveDateTime>,",
            "    ${2:// campo personalizado}",
            "}",
            "",
            "impl ${1:EntityName} {",
            "    pub fn new(${3:}) -> Result<Self, ${1:EntityName}Error> {",
            "        // Validaciones",
            "        ${4:// if ... return Err(${1:EntityName}Error::ValidationError(\"custom_message_here\".to_string())) }",
            "        Ok(Self {",
            "            id: Uuid::new_v4(),",
            "            created_at: chrono::Utc::now().naive_utc(),",
            "            updated_at: chrono::Utc::now().naive_utc(),",
            "            deleted: false,",
            "            deleted_at: None,",
            "            ${5:// campos personalizados}",
            "        })",
            "    }",
            "",
            "    pub fn from_repository(",
            "        id: Uuid,",
            "        created_at: NaiveDateTime,",
            "        updated_at: NaiveDateTime,",
            "        deleted: bool,",
            "        deleted_at: Option<NaiveDateTime>,",
            "        ${6:/* campos personalizados */}",
            "    ) -> Self {",
            "        Self {",
            "            id,",
            "            created_at,",
            "            updated_at,",
            "            deleted,",
            "            deleted_at,",
            "            ${7:// campos personalizados}",
            "        }",
            "    }",
            "",
            "    pub fn id(&self) -> Uuid {",
            "        self.id",
            "    }",
            "",
            "    pub fn created_at(&self) -> NaiveDateTime {",
            "        self.created_at",
            "    }",
            "",
            "    pub fn updated_at(&self) -> NaiveDateTime {",
            "        self.updated_at",
            "    }",
            "",
            "    pub fn deleted(&self) -> bool {",
            "        self.deleted",
            "    }",
            "",
            "    pub fn deleted_at(&self) -> Option<NaiveDateTime> {",
            "        self.deleted_at",
            "    }",
            "",
            "    ${8:// otros getters}",
            "}",
            "",
            "impl Identifiable for ${1:EntityName} {",
            "    fn id(&self) -> Uuid {",
            "        self.id",
            "    }",
            "    fn created_at(&self) -> NaiveDateTime {",
            "        self.created_at",
            "    }",
            "    fn updated_at(&self) -> NaiveDateTime {",
            "        self.updated_at",
            "    }",
            "    fn deleted(&self) -> bool {",
            "        self.deleted",
            "    }",
            "    fn deleted_at(&self) -> Option<NaiveDateTime> {",
            "        self.deleted_at",
            "    }",
            "}",
            "",
            "#[cfg(test)]",
            "mod tests {",
            "    use super::*;",
            "",
            "    #[test]",
            "    fn should_${9:use_case}_when_${10:condition}() {",
            "        // Arrange",
            "        // Act",
            "        // Assert",
            "        ",
            "    }",
            "}",
        ],
        "scope": "rust",
        "description": "Plantilla para modelos de entidades de dominio (business/domain/[entity]/model.rs)"
    },
    "Business Domain Use Case": {
        "prefix": "business-use-case",
        "body": [
            "use std::sync::Arc;",
            "",
            "use async_trait::async_trait;",
            "",
            "use uuid::Uuid;",
            "",
            "use crate::domain::${3:module}::{",
            "    errors::${1:Entity}Error,",
            "    model::${1:Entity},",
            "    repository::${1:Entity}Repository,",
            "};",
            "",
            "#[async_trait]",
            "pub trait ${2:UseCase}${1:Entity}UseCase: Send + Sync {",
            "    async fn execute(&self) -> Result<${1:Entity}, ${1:Entity}Error>;",
            "}",
            "",
            "pub struct ${2:UseCase}${1:Entity}UseCaseImpl {",
            "    pub repository: Arc<dyn ${1:Entity}Repository + Send + Sync>,",
            "}"
        ],
        "scope": "rust",
        "description": "Plantilla para un caso de uso genérico (business/domain/[entity]/use_cases.rs)."
    },
    "Business Domain Use Case Create": {
        "prefix": "business-use-case-create",
        "body": [
            "use std::sync::Arc;",
            "",
            "use async_trait::async_trait;",
            "",
            "use crate::domain::${1:module}::{",
            "    errors::${2:Entity}Error,",
            "    model::${2:Entity},",
            "    repository::${2:Entity}Repository,",
            "};",
            "",
            "#[async_trait]",
            "pub trait Create${2:Entity}UseCase: Send + Sync {",
            "    async fn execute(&self, ${3:params}) -> Result<${2:Entity}, ${2:Entity}Error>;",
            "}",
            "",
            "pub struct Create${2:Entity}UseCaseImpl {",
            "    pub repository: Arc<dyn ${2:Entity}Repository + Send + Sync>,",
            "}",
        ],
        "scope": "rust",
        "description": "Plantilla para un caso de uso CREATE (business/domain/[entity]/use_cases/create.rs)"
    },
    "Business Domain Use Case Update": {
        "prefix": "business-use-case-update",
        "body": [
            "use std::sync::Arc;",
            "",
            "use async_trait::async_trait;",
            "",
            "use crate::domain::${1:module}::{",
            "    errors::${2:Entity}Error,",
            "    model::${2:Entity},",
            "    repository::${2:Entity}Repository,",
            "};",
            "",
            "#[async_trait]",
            "pub trait Update${2:Entity}UseCase: Send + Sync {",
            "    async fn execute(&self, entity: &${2:Entity}) -> Result<${2:Entity}, ${2:Entity}Error>;",
            "}",
            "",
            "pub struct Update${2:Entity}UseCaseImpl {",
            "    pub repository: Arc<dyn ${2:Entity}Repository + Send + Sync>,",
            "}",
        ],
        "scope": "rust",
        "description": "Plantilla para un caso de uso UPDATE (business/domain/[entity]/use_cases/update.rs)"
    },
    "Business Domain Use Case Delete": {
        "prefix": "business-use-case-delete",
        "body": [
            "use std::sync::Arc;",
            "",
            "use async_trait::async_trait;",
            "",
            "use uuid::Uuid;",
            "",
            "use crate::domain::${1:module}::{",
            "    errors::${2:Entity}Error,",
            "    repository::${2:Entity}Repository,",
            "};",
            "",
            "#[async_trait]",
            "pub trait Delete${2:Entity}UseCase: Send + Sync {",
            "    async fn execute(&self, id: &Uuid) -> Result<(), ${2:Entity}Error>;",
            "}",
            "",
            "pub struct Delete${2:Entity}UseCaseImpl {",
            "    pub repository: Arc<dyn ${2:Entity}Repository + Send + Sync>,",
            "}",
        ],
        "scope": "rust",
        "description": "Plantilla para un caso de uso DELETE (business/domain/[entity]/use_cases/delete.rs)"
    },
    "Business Domain Use Case GetBy": {
        "prefix": "business-use-case-get-by",
        "body": [
            "use std::sync::Arc;",
            "",
            "use async_trait::async_trait;",
            "",
            "use crate::domain::${1:module}::{",
            "    errors::${2:Entity}Error,",
            "    model::${2:Entity},",
            "    repository::${2:Entity}Repository,",
            "};",
            "",
            "#[async_trait]",
            "pub trait GetBy${2:Entity}UseCase: Send + Sync {",
            "    async fn execute(&self) -> Result<Vec<${2:Entity}>, ${2:Entity}Error>;",
            "}",
            "",
            "pub struct GetBy${2:Entity}UseCaseImpl {",
            "    pub repository: Arc<dyn ${2:Entity}Repository + Send + Sync>,",
            "}",
        ],
        "scope": "rust",
        "description": "Plantilla para un caso de uso GET_BY (business/domain/[entity]/use_cases/get_by.rs)"
    },
    "Business Domain Errors": {
        "prefix": "business-domain-errors",
        "body": [
            "use thiserror::Error;",
            "",
            "use crate::domain::errors::RepositoryError;",
            "",
            "#[derive(Debug, Error)]",
            "pub enum ${1:Entity}Error {",
            "    #[error(\"${2:entity}.not_found\")]",
            "    NotFound(String),",
            "    #[error(\"${2:entity}.already_exists\")]",
            "    Duplicate${1:entity}(String),",
            "    #[error(\"${2:entity}.repository_error\")]",
            "    RepositoryError(String),",
            "    #[error(\"${2:entity}.validation_error\")]",
            "    ValidationError(String),",
            "    #[error(\"${2:entity}.unknown\")]",
            "    Unknown(#[from] anyhow::Error),",
            "}",
            "",
            "/**",
            " * Matches the RepositoryError to the ${1}Error.",
            " */",
            "impl From<RepositoryError> for ${1}Error {",
            "    fn from(err: RepositoryError) -> Self {",
            "        match err {",
            "            RepositoryError::NotFound(msg) => Self::NotFound(msg),",
            "            RepositoryError::Persistence(msg) => Self::RepositoryError(msg),",
            "            RepositoryError::DatabaseError(msg) => Self::RepositoryError(msg),",
            "            RepositoryError::Duplicated(msg) => Self::Duplicate${1}(msg),",
            "        }",
            "    }",
            "}"
        ],
        "scope": "rust",
        "description": "Plantilla de error para el modelo de dominio (business/domain/[entity]/errors.rs)"
    },
    "Business Domain Repository": {
        "prefix": "business-domain-repository",
        "body": [
            "use async_trait::async_trait;",
            "use uuid::Uuid;",
            "",
            "use crate::domain::errors::RepositoryError;",
            "",
            "use super::model::${1:Entity};",
            "",
            "#[async_trait]",
            "pub trait ${1:Entity}Repository: Send + Sync {",
            "    async fn save(&self, ${2:entity}: &${1:Entity}) -> Result<(), RepositoryError>;",
            "    async fn find_all(&self) -> Result<Vec<${1:Entity}>, RepositoryError>;",
            "    async fn find_by_id(&self, id: &Uuid) -> Result<${1:Entity}, RepositoryError>;",
            "    async fn delete(&self, id: &Uuid) -> Result<(), RepositoryError>;",
            "    async fn update(&self, ${2:entity}: &${1:Entity}) -> Result<(), RepositoryError>;",
            "}"
        ],
        "scope": "rust",
        "description": "Plantilla para un repositorio del modelo (business/domain/[entity]/repository.rs)"
    },
    /**
    * Application Layer Snippets
    */
    "Business Application Use Case": {
        "prefix": "app-use-case",
        "body": [
            "use async_trait::async_trait;",
            "use tracing::info;",
            "",
            "use crate::domain::${1:module}::{",
            "   errors::${2:Entity}Error,",
            "   model::${2:Entity},",
            "   repository::${2:Entity}Repository,",
            "   use_cases::${3:use_case_module}::{${4:UseCase}${2:Entity}UseCase, ${4:UseCase}${2:Entity}UseCaseImpl},",
            "};",
            "",
            "impl ${4:UseCase}${2:Entity}UseCaseImpl {",
            "    pub fn new(repository: Arc<dyn ${2:Entity}Repository + Send + Sync>) -> Self {",
            "        Self { repository }",
            "    }",
            "}",
            "",
            "#[async_trait]",
            "impl ${4:UseCase}${2:Entity}UseCase for ${4:UseCase}${2:Entity}UseCaseImpl {",
            "    async fn execute(&self) -> Result<${2:Entity}, ${2:Entity}Error> {",
            "        info!(\"Ejecutando ${4:UseCase}${2:Entity}UseCase\");",
            "        // Lógica del caso de uso",
            "    }",
            "}",
            "",
            "#[cfg(test)]",
            "mod tests {",
            "    use super::*;",
            "    use std::sync::Arc;",
            "   use::crate::{",
            "        domain::${1:module}::{",
            "           errors::${2:Entity}Error,",
            "           repository::mock_${1:module}_repository::Mock${2:Entity}Repository,",
            "           }",
            "        tests::mocks::mock_${2:entity}_repository::Mock${2:Entity}Repository,",
            "    };",
            "",
            "   // Helper para construir la usecase con el mock",
            "   fn build_use_case(mock: Arc<dyn ${2:Entity}Repository>) -> ${4:UseCase}${2:Entity}UseCaseImpl {",
            "       ${4:UseCase}${2:Entity}UseCaseImpl::new(mock)",
            "   }",
            "",
            "   #[tokio::test]",
            "   async fn should_${5:use_case}_when_${6:condition}() {",
            "       // Arrange",
            "       // Act",
            "       // Assert",
            "   }",
            "}",
        ],
        "scope": "rust",
        "description": "Plantilla para un caso de uso de aplicación (business/application/[entity]/use_cases/[use_case].rs)"
    },
    "Business Application Use Case Create": {
        "prefix": "app-use-case-create",
        "body": [
            "use std::sync::Arc;",
            "",
            "use async_trait::async_trait;",
            "use tracing::info;",
            "",
            "use crate::domain::${1:module}::{",
            "   errors::${2:Entity}Error,",
            "   model::${2:Entity},",
            "   repository::${2:Entity}Repository,",
            "   use_cases::${3:use_case_module}::{Create${2:Entity}UseCase, Create${2:Entity}UseCaseImpl},",
            "};",
            "",
            "impl Create${2:Entity}UseCaseImpl {",
            "    pub fn new(repository: Arc<dyn ${2:Entity}Repository + Send + Sync>) -> Self {",
            "        Self { repository }",
            "    }",
            "}",
            "",
            "#[async_trait]",
            "impl Create${2:Entity}UseCase for Create${2:Entity}UseCaseImpl {",
            "    async fn execute(&self) -> Result<${2:Entity}, ${2:Entity}Error> {",
            "        info!(\"Creación de ${1:module}\");",
            "        let entity = ${2:Entity}::new(${4:params})?;",
            "",
            "        self.repository.save(&entity).await?;",
            "",
            "        Ok(entity)",
            "    }",
            "}",
            "",
            "#[cfg(test)]",
            "mod tests {",
            "    use super::*;",
            "    use std::sync::Arc;",
            "    crate::tests::mocks::mock_${1:module}_repository::Mock${2:Entity}Repository;",
            "",
            "   // Helper para construir la usecase con el mock",
            "   fn build_use_case(mock: Arc<dyn ${2:Entity}Repository>) -> Create${2:Entity}UseCaseImpl {",
            "       Create${2:Entity}UseCaseImpl::new(mock)",
            "   }",
            "",
            "   #[tokio::test]",
            "   async fn should_create_${1:module}_successfully() {",
            "       // Arrange",
            "       let mut mock = Mock${2:Entity}Repository::new();",
            "       mock.expect_save().returning(|_| Ok(()));",
            "       let use_case = build_use_case(Arc::new(mock));",
            "       let entity = ${2:Entity}::new(${4:params})?;",
            "",
            "       // Act",
            "       let result = use_case.execute().await;",
            "",
            "       // Assert",
            "       assert!(result.is_ok());",
            "       let created_entity = result.unwrap();",
            "       // assert_eq!(created_entity.id(), entity.id());",
            "   }",
            "",
            "   #[tokio::test]",
            "   async fn should_fail_when_${5:condition}() {",
            "       // Arrange",
            "       // Act",
            "       // Assert",
            "   }",
            "}",
        ],
        "scope": "rust",
        "description": "Plantilla para un caso de uso CREATE básico de aplicación (business/application/[entity]/use_cases/create.rs)"
    },
    "Business Application Use Case Update": {
        "prefix": "app-use-case-update",
        "body": [
            "use std::sync::Arc;",
            "",
            "use async_trait::async_trait;",
            "use tracing::info;",
            "",
            "use crate::domain::${1:module}::{",
            "   errors::${2:Entity}Error,",
            "   model::${2:Entity},",
            "   repository::${2:Entity}Repository,",
            "   use_cases::${3:use_case_module}::{Update${2:Entity}UseCase, Update${2:Entity}UseCaseImpl},",
            "};",
            "",
            "impl Update${2:Entity}UseCaseImpl {",
            "    pub fn new(repository: Arc<dyn ${2:Entity}Repository + Send + Sync>) -> Self {",
            "        Self { repository }",
            "    }",
            "}",
            "",
            "#[async_trait]",
            "impl Update${2:Entity}UseCase for Update${2:Entity}UseCaseImpl {",
            "    async fn execute(&self, ${1:module}: &${2:Entity}) -> Result<${2:Entity}, ${2:Entity}Error> {",
            "        info!(\"Actualización de ${1:module}\");",
            "",
            "        self.repository.update(${1:module})",
            "            .await",
            "            .map_err(|e| e.into())",
            "            .map(|_| ${1:module}.clone())",
            "",
            "    }",
            "}",
            "",
            "#[cfg(test)]",
            "mod tests {",
            "    use super::*;",
            "    use std::sync::Arc;",
            "    use crate::{",
            "        domain::{",
            "            errors::RepositoryError,",
            "            ${1:module}::{errors::${2:Entity}Error, repository::${2:Entity}Repository},",
            "        },",
            "        tests::mocks::mock_${1:module}_repository::Mock${2:Entity}Repository,",
            "    };",
            "",
            "   // Helper para construir la usecase con el mock",
            "   fn build_use_case(mock: Arc<dyn ${2:Entity}Repository>) -> Update${2:Entity}UseCaseImpl {",
            "       Update${2:Entity}UseCaseImpl::new(mock)",
            "   }",
            "",
            "   #[tokio::test]",
            "   async fn should_update_${1:module}_successfully() {",
            "       // Arrange",
            "       let mut mock = Mock${2:Entity}Repository::new();",
            "       mock.expect_update().returning(|_| Ok(()));",
            "       let use_case = build_use_case(Arc::new(mock));",
            "       let entity = ${2:Entity}::new(${4:params}).unwrap();",
            "",
            "       // Act",
            "       let result = use_case.execute(&entity).await;",
            "",
            "       // Assert",
            "       assert!(result.is_ok());",
            "       let updated_entity = result.unwrap();",
            "       assert_eq!(updated_entity.id(), entity.id());",
            "   }",
            "",
            "   #[tokio::test]",
            "   async fn should_fail_when_not_found() {",
            "       // Arrange",
            "       let entity = ${2:Entity}::new(${4:params}).unwrap();",
            "       let mut mock = Mock${2:Entity}Repository::new();",
            "       mock.expect_update().returning(|_| Err(RepositoryError::NotFound(\"not_found\".to_string())));",
            "       let use_case = build_use_case(Arc::new(mock));",
            "",
            "       // Act",
            "       let result = use_case.execute(&entity).await;",
            "",
            "       // Assert",
            "       assert!(result.is_err());",
            "       assert!(matches!(result, Err(${2:Entity}Error::NotFound(_))));",
            "   }",
            "   #[tokio::test]",
            "   async fn should_fail_when_repository_returns_error() {",
            "       // Arrange",
            "       let mut mock = Mock${2:Entity}Repository::new();",
            "       mock.expect_update()",
            "            .returning(|_| Err(RepositoryError::Persistence(\"DB fail\".into())));",
            "       let use_case = build_use_case(Arc::new(mock));",
            "",
            "       // Act",
            "       let result = use_case.execute(&entity).await;",
            "",
            "       // Assert",
            "       assert!(result.is_err());",
            "       assert!(matches!(result, Err(${2:Entity}Error::RepositoryError(_))));",
            "   }",
            "}",
            "",
        ],
        "scope": "rust",
        "description": "Plantilla para un caso de uso UPDATE básico de aplicación (business/application/[entity]/use_cases/update.rs)"
    },
    "Business Application Use Case Delete": {
        "prefix": "app-use-case-delete",
        "body": [
            "use std::sync::Arc;",
            "",
            "use async_trait::async_trait;",
            "use tracing::info;",
            "use uuid::Uuid;",
            "",
            "use crate::domain::${1:module}::{",
            "   errors::${2:Entity}Error,",
            "   repository::${2:Entity}Repository,",
            "   use_cases::${3:use_case_module}::{Delete${2:Entity}UseCase, Delete${2:Entity}UseCaseImpl},",
            "};",
            "",
            "impl Delete${2:Entity}UseCaseImpl {",
            "    pub fn new(repository: Arc<dyn ${2:Entity}Repository + Send + Sync>) -> Self {",
            "        Self { repository }",
            "    }",
            "}",
            "",
            "#[async_trait]",
            "impl Delete${2:Entity}UseCase for Delete${2:Entity}UseCaseImpl {",
            "    async fn execute(&self, id: &Uuid) -> Result<(), ${2:Entity}Error> {",
            "        info!(\"Eliminación de ${1:module}\");",
            "",
            "        self.repository.delete(id).await.map_err(|e| e.into())",
            "    }",
            "}",
            "",
            "#[cfg(test)]",
            "mod tests {",
            "    use super::*;",
            "    use std::sync::Arc;",
            "    use crate::{",
            "        domain::{",
            "            errors::RepositoryError,",
            "            ${1:module}::{errors::${2:Entity}Error, repository::${2:Entity}Repository},",
            "        },",
            "        tests::mocks::mock_${1:module}_repository::Mock${2:Entity}Repository,",
            "    };",
            "",
            "   // Helper para construir la usecase con el mock",
            "   fn build_use_case(mock: Arc<dyn ${2:Entity}Repository>) -> Delete${2:Entity}UseCaseImpl {",
            "       Delete${2:Entity}UseCaseImpl::new(mock)",
            "   }",
            "",
            "   #[tokio::test]",
            "   async fn should_delete_${1:module}_successfully() {",
            "       // Arrange",
            "       let mut mock = Mock${2:Entity}Repository::new();",
            "       mock.expect_delete().returning(|_| Ok(()));",
            "       let use_case = build_use_case(Arc::new(mock));",
            "       let id = Uuid::new_v4();",
            "",
            "       // Act",
            "       let result = use_case.execute(&id).await;",
            "",
            "       // Assert",
            "       assert!(result.is_ok());",
            "   }",
            "",
            "   #[tokio::test]",
            "   async fn should_fail_when_not_found() {",
            "       // Arrange",
            "       let mut mock = Mock${2:Entity}Repository::new();",
            "       mock.expect_delete().returning(|_| Err(RepositoryError::NotFound(\"not_found\".to_string())));",
            "       let use_case = build_use_case(Arc::new(mock));",
            "       let id = Uuid::new_v4();",
            "",
            "       // Act",
            "       let result = use_case.execute(&id).await;",
            "",
            "       // Assert",
            "       assert!(result.is_err());",
            "       assert!(matches!(result, Err(${2:Entity}Error::NotFound(_))));",
            "   }",
            "   #[tokio::test]",
            "   async fn should_fail_when_repository_returns_error() {",
            "       // Arrange",
            "       let mut mock = Mock${2:Entity}Repository::new();",
            "       mock.expect_delete()",
            "            .returning(|_| Err(RepositoryError::Persistence(\"DB fail\".into())));",
            "       let use_case = build_use_case(Arc::new(mock));",
            "       let id = Uuid::new_v4();",
            "",
            "       // Act",
            "       let result = use_case.execute(&id).await;",
            "",
            "       // Assert",
            "       assert!(result.is_err());",
            "       assert!(matches!(result, Err(${2:Entity}Error::RepositoryError(_))));",
            "   }",
            "}",
        ],
        "scope": "rust",
        "description": "Plantilla para un caso de uso DELETE básico de aplicación (business/application/[entity]/use_cases/delete.rs)"
    },
    "Business Application Use Case GetBy": {
        "prefix": "app-use-case-get-by",
        "body": [
            "use std::sync::Arc;",
            "",
            "use async_trait::async_trait;",
            "use tracing::info;",
            "",
            "use crate::domain::${1:module}::{",
            "   errors::${2:Entity}Error,",
            "   model::${2:Entity},",
            "   repository::${2:Entity}Repository,",
            "   use_cases::${3:use_case_module}::{GetBy${2:Entity}UseCase, GetBy${2:Entity}UseCaseImpl},",
            "};",
            "",
            "impl GetBy${2:Entity}UseCaseImpl {",
            "    pub fn new(repository: Arc<dyn ${2:Entity}Repository + Send + Sync>) -> Self {",
            "        Self { repository }",
            "    }",
            "}",
            "",
            "#[async_trait]",
            "impl GetBy${2:Entity}UseCase for GetBy${2:Entity}UseCaseImpl {",
            "    async fn execute(&self) -> Result<Vec<${2:Entity}>, ${2:Entity}Error> {",
            "        info!(\"Obteniendo ${1:module}\");",
            "",
            "        self.repository.find_all().await.map_err(|e| e.into())",
            "    }",
            "}",
            "",
            "#[cfg(test)]",
            "mod tests {",
            "    use super::*;",
            "    use std::sync::Arc;",
            "    use crate::{",
            "        domain::{",
            "            errors::RepositoryError,",
            "            ${1:module}::{errors::${2:Entity}Error, repository::${2:Entity}Repository},",
            "        },",
            "        tests::mocks::mock_${1:module}_repository::Mock${2:Entity}Repository,",
            "    };",
            "",
            "   // Helper para construir la usecase con el mock",
            "   fn build_use_case(mock: Arc<dyn ${2:Entity}Repository>) -> GetBy${2:Entity}UseCaseImpl {",
            "       GetBy${2:Entity}UseCaseImpl::new(mock)",
            "   }",
            "",
            "   #[tokio::test]",
            "   async fn should_get_${1:module}_successfully() {",
            "       // Arrange",
            "       let mut mock = Mock${2:Entity}Repository::new();",
            "       mock.expect_find_all().returning(|| {",
            "           Ok(vec![${2:Entity}::new(${4:params}).unwrap()])",
            "       });",
            "       let use_case = build_use_case(Arc::new(mock));",
            "",
            "       // Act",
            "       let result = use_case.execute().await;",
            "",
            "       // Assert",
            "       assert!(result.is_ok());",
            "       let found_entities = result.unwrap();",
            "       assert_eq!(found_entities.len(), 1);",
            "       // assert_eq!(found_entities[0].id(), entity.id());",
            "   }",
            "",
            "   #[tokio::test]",
            "   async fn should_return_empty_list_when_not_found() {",
            "       // Arrange",
            "       let mut mock = Mock${2:Entity}Repository::new();",
            "       mock.expect_find_all().returning(|| Ok(vec![]));",
            "       let use_case = build_use_case(Arc::new(mock));",
            "",
            "       // Act",
            "       let result = use_case.execute().await;",
            "",
            "       // Assert",
            "       assert!(result.is_ok());",
            "       let found_entities = result.unwrap();",
            "       assert_eq!(found_entities.len(), 0);",
            "   }",
            "   #[tokio::test]",
            "   async fn should_fail_when_repository_returns_error() {",
            "       // Arrange",
            "       let mut mock = Mock${2:Entity}Repository::new();",
            "       mock.expect_find_all()",
            "            .returning(|| Err(RepositoryError::Persistence(\"DB fail\".into())));",
            "       let use_case = build_use_case(Arc::new(mock));",
            "",
            "       // Act",
            "       let result = use_case.execute().await;",
            "",
            "       // Assert",
            "       assert!(result.is_err());",
            "       assert!(matches!(result, Err(${2:Entity}Error::RepositoryError(_))));",
            "   }",
            "}",
        ],
        "scope": "rust",
        "description": "Plantilla para un caso de uso GET_BY básico de aplicación (business/application/[entity]/use_cases/get_by.rs)"
    },
    /**
    * Presentation Layer Snippets
    */
    "Presentation Rest Api Router Entity Controller": {
        "prefix": "rest-api-router-entity-controller",
        "body": [
            "pub mod ${1:module_name} {",
            "\tpub mod controller;",
            "\tpub mod dto;",
            "}"
        ],
        "scope": "rust",
        "description": "Crea un submódulo de router con controller y dto (presentation/rest-api/src/router/[entity]/controller.rs)"
    },
    /**
    * Infrastructure Layer Snippets
    */
    "Infrastructure Lib Persistance": {
        "prefix": "lib-persistence",
        "body": [
            "pub mod ${1:module_name} {",
            "\tpub mod data_model;",
            "\tpub mod repository;",
            "}"
        ],
        "scope": "rust",
        "description": "Crea un submódulo dentro de un módulo de persistencia con data_model y repository (infrastructure/persistance -> pub mod [postgres|sqlite|redis|...])"
    },
    "Infrastructure Postgres Data Model": {
        "prefix": "postgres-data-model",
        "body": [
            "use business::domain::${1:module_name}::{",
            "    model::${1:Entity},",
            "};",
            "",
            "// #[derive(Debug)]                       // Para imprimir en consola (útil en desarrollo)",
            "// #[derive(Clone)]                      // Para clonar structs fácilmente",
            "// #[derive(Serialize, Deserialize)]     // Para convertir desde/hacia JSON u otros formatos",
            "// #[derive(PartialEq, Eq, Hash)]        // Para comparar, o usar en HashMaps o HashSets",
            "// #[derive(Default)]                    // Para construir una instancia vacía si aplica",
            "// #[derive(FromRow)]                   // Para convertir desde/hacia una fila de la base de datos",
            "#[derive(Debug, Serialize, Deserialize, FromRow)]",
            "pub struct ${1:Entity}DataModel {",
            "    pub id: Uuid,",
            "    pub created_at: NaiveDateTime,",
            "    pub updated_at: NaiveDateTime,",
            "    pub deleted: bool,",
            "    pub deleted_at: Option<NaiveDateTime>,",
            "    ${2:// campo personalizado}",
            "}",
            "",
            "impl From<${1:Entity}> for ${1:Entity}DataModel {",
            "    fn from(entity: ${1:Entity}) -> Self {",
            "        Self {",
            "            id: entity.id(),",
            "            created_at: entity.created_at(),",
            "            updated_at: entity.updated_at(),",
            "            deleted: entity.deleted(),",
            "            deleted_at: entity.deleted_at(),",
            "            ${3:// campos personalizados}",
            "        }",
            "    }",
            "}",
            "",
            "impl TryFrom<&${1:Entity}DataModel> for ${1:Entity} {",
            "    type Error = ${1:Entity}Error;",
            "",
            "    fn try_from(data_model: &${1:Entity}DataModel) -> Result<Self, Self::Error> {",
            "   Ok(${1:Entity}::from_repository(",
            "            data_model.id,",
            "            data_model.created_at,",
            "            data_model.updated_at,",
            "            data_model.deleted,",
            "            data_model.deleted_at,",
            "            ${4:// campos personalizados}",
            "        ))",
            "    }",
            "}",
            "",
            "impl TryFrom<&${1:Entity}DataModel> for ${1:Entity}DataModel {",
            "    type Error = ${1:Entity}Error;",
            "",
            "    fn try_from(data_model: &${1:Entity}DataModel) -> Result<Self, Self::Error> {",
            "        ${1:Entity}::try_from(data_model)",
            "    }",
            "}",
        ],
        "scope": "rust",
        "description": "Plantilla para un modelo de datos de Postgres (infrastructure/persistence/postgres/data_model.rs)"
    }
}